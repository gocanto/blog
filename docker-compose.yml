# Define the source of the secrets on the host machine.
secrets:
    postgres_user:
        file: ${POSTGRES_USER_SECRET_PATH:-./database/infra/secrets/postgres_user}
    postgres_password:
        file: ${POSTGRES_PASSWORD_SECRET_PATH:-./database/infra/secrets/postgres_password}
    postgres_db:
        file: ${POSTGRES_DB_SECRET_PATH:-./database/infra/secrets/postgres_db}

volumes:
    caddy_data:
    caddy_config:
    # --- DB: Define a named volume at the top level.
    #     Docker will manage its lifecycle.
    oullin_db_data:
        driver: local

networks:
    caddy_net:
        name: caddy_net
        driver: bridge
    oullin_net:
        name: oullin_net
        driver: bridge

services:
        caddy_prod:
            build:
                context: ./caddy
                dockerfile: Dockerfile
                args:
                    - CADDY_VERSION=2.10.0
            # This service will only run when the 'prod' profile is active.
            profiles: ["prod"]
            container_name: oullin_proxy_prod
            restart: unless-stopped
            depends_on:
                - api
            ports:
                - "80:80"
                - "443:443"
                - "443:443/udp" # Required for HTTP/3
            volumes:
                - caddy_data:/data
                - caddy_config:/config
                - ./caddy/Caddyfile.prod:/etc/caddy/Caddyfile
            networks:
                - caddy_net

        caddy_local:
            build:
                context: ./caddy
                dockerfile: Dockerfile
                args:
                    - CADDY_VERSION=latest
            # This service will only run when the 'local' profile is active.
            profiles: ["local"]
            container_name: oullin_local_proxy
            restart: unless-stopped
            depends_on:
                - api
            ports:
                - "8080:80"
                - "8443:443"
            volumes:
                - caddy_data:/data
                - caddy_config:/config
                - ./caddy/Caddyfile.local:/etc/caddy/Caddyfile
            networks:
                - caddy_net

        api:
            env_file:
                - .env
            environment:
                # --- These variables inject the database credentials directly into the
                #     API container at runtime. This ensures the Go application uses the
                #     same secure credentials that the 'api-db' service is configured with.
                ENV_DB_USER_NAME: ${ENV_DB_USER_NAME}
                ENV_DB_USER_PASSWORD: ${ENV_DB_USER_PASSWORD}
                ENV_DB_DATABASE_NAME: ${ENV_DB_DATABASE_NAME}
                # --- This ensures the Go web server listens for connections from other
                #     containers (like Caddy), not just from within itself.
                ENV_DB_HOST: api-db
                ENV_HTTP_HOST: 0.0.0.0
            build:
                context: .
                dockerfile: ./docker/dockerfile-api
                args:
                    - APP_VERSION=v1.0.0-release
                    - APP_HOST_PORT=${ENV_HTTP_PORT}
                    - APP_USER=${ENV_DOCKER_USER}
                    - APP_GROUP=${ENV_DOCKER_USER_GROUP}
            container_name: oullin_api
            restart: unless-stopped
            depends_on:
                api-db:
                    condition: service_healthy
            expose:
                - ${ENV_HTTP_PORT}
            networks:
                - caddy_net
                - oullin_net

        api-db-migrate:
            image: migrate/migrate:v4.18.3
            container_name: oullin_db_migrate
            networks:
                - oullin_net
            volumes:
                - ./database/infra/migrations:/migrations
                - ./database/infra/scripts/run-migration.sh:/run-migration.sh
            secrets:
                - postgres_user
                - postgres_password
                - postgres_db
            entrypoint: /run-migration.sh
            command: ""
            depends_on:
                api-db:
                    condition: service_healthy
            restart: no

        api-db:
            # Ensure the database always restarts on server reboot or crash.
            restart: always

            # --- Use this lightweight and more secure 'alpine' image.
            #     A specific version (e.g., 16) is pinned to avoid unexpected updates.
            image: postgres:17.3-alpine
            container_name: oullin_db

            env_file:
                - .env
            networks:
                - oullin_net

            # --- Use Docker Secrets instead of .env files for credentials.
            #     The given postgres image automatically reads from files specified by these _FILE variables.
            environment:
                POSTGRES_USER_FILE: /run/secrets/postgres_user
                POSTGRES_PASSWORD_FILE: /run/secrets/postgres_password
                POSTGRES_DB_FILE: /run/secrets/postgres_db
                PGDATA: /var/lib/postgresql/data/pgdata

            # --- Securing port binding.
            #     Binds the port ONLY to my VPS's localhost (127.0.0.1).
            #     This prevents any direct access to the public internet.
            #     My applications running on the same VPS can connect to it.
            #     The ':-5432' provides a fallback default port if ENV_DB_PORT is not set.
            ports:
                - "127.0.0.1:${ENV_DB_PORT:-5432}:5432"

            # --- Define which secrets this service has access to.
            #     These secrets are mounted securely in memory at /run/secrets/
            secrets:
                - postgres_user
                - postgres_password
                - postgres_db
            volumes:
                # Use a Docker Named Volume for data persistence.
                # This decouples my critical data from the host's file structure, making it
                # more robust, portable, and managed entirely by Docker.
                - oullin_db_data:/var/lib/postgresql/data
                # Mount SSL certs and config files as read-only (:ro) for security.
                - ./database/infra/ssl/server.crt:/etc/ssl/certs/server.crt:ro
                - ./database/infra/ssl/server.key:/etc/ssl/private/server.key
                - ./database/infra/config/postgresql.conf:/etc/postgresql/postgresql.conf:ro
                - ./database/infra/scripts/healthcheck.sh:/healthcheck.sh:ro

            logging:
                driver: "json-file"
                options:
                    max-file: 20
                    max-size: 10M

            # --- This command sets the key permissions and explicitly tells
            #     Postgres to use my mounted configuration file for greater reliability.
            command: >
                sh -c "chown postgres:postgres /etc/ssl/private/server.key && chmod 600 /etc/ssl/private/server.key && exec docker-entrypoint.sh -c 'config_file=/etc/postgresql/postgresql.conf'"

            # --- The test simply executes our robust script. All complex logic is inside it.
            #     We use CMD instead of CMD-SHELL because our file is an executable.
            healthcheck:
                test: ["CMD", "/healthcheck.sh"]
                interval: 10s
                timeout: 5s
                retries: 5
