package main

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"
)

// Constants for our token prefixes.
const (
	PublicKeyPrefix = "pk_"
	SecretKeyPrefix = "sk_"
	AuthLevelPublic = "public"
	AuthLevelSecret = "secret"
)

// A simple in-memory store to hold our valid tokens and map them to an account ID.
// In a real application, this would be a database table.
var tokenStore = make(map[string]string)

// generateSecureToken creates a secure, SHA256-hashed token from random data.
func generateSecureToken(saltLength int) (string, error) {
	// Create a random salt to ensure the hash is unique.
	salt := make([]byte, saltLength)
	if _, err := rand.Read(salt); err != nil {
		return "", err
	}

	// Create a new SHA256 hasher.
	hasher := sha256.New()

	// Write the random salt to the hasher.
	hasher.Write(salt)

	// Get the resulting hash and encode it as a hex string.
	hashBytes := hasher.Sum(nil)
	return hex.EncodeToString(hashBytes), nil
}

// setupNewAccount generates a new set of public and secret keys for a given account ID
// and stores them in our tokenStore.
func setupNewAccount(accountID string) (publicKey, secretKey string, err error) {
	// Generate the core of the keys using a SHA256 hash.
	// The input length (16) is for the random salt; the output length is fixed by SHA256.
	publicKeyPart, err := generateSecureToken(16)
	if err != nil {
		return "", "", fmt.Errorf("failed to generate public key: %w", err)
	}
	secretKeyPart, err := generateSecureToken(16)
	if err != nil {
		return "", "", fmt.Errorf("failed to generate secret key: %w", err)
	}

	// Add the prefixes
	publicKey = PublicKeyPrefix + publicKeyPart
	secretKey = SecretKeyPrefix + secretKeyPart

	// Store the valid tokens, mapping them back to the account ID
	tokenStore[publicKey] = accountID
	tokenStore[secretKey] = accountID

	return publicKey, secretKey, nil
}

// validateBearerToken performs a proper validation of a given token.
// It returns the accountID, authentication level, and an error if validation fails.
func validateBearerToken(token string) (accountID string, authLevel string, err error) {
	// 1. Check if the token exists in our store. This is the primary validation.
	accountID, found := tokenStore[token]
	if !found {
		return "", "", fmt.Errorf("token not found or invalid")
	}

	// 2. Determine the authentication level based on the token's prefix.
	if strings.HasPrefix(token, PublicKeyPrefix) {
		return accountID, AuthLevelPublic, nil
	}

	if strings.HasPrefix(token, SecretKeyPrefix) {
		return accountID, AuthLevelSecret, nil
	}

	// 3. If the token was found but has no valid prefix, it's a format error.
	// This case should be rare if tokens are always generated by our system.
	return "", "", fmt.Errorf("token has an unknown format")
}

// simulateApiRequest checks a token and simulates API calls.
func simulateApiRequest(token string) {
	// Safely create a truncated token for display purposes to avoid logging secrets.
	displayToken := token
	const maxDisplayLen = 20
	if len(displayToken) > maxDisplayLen {
		displayToken = displayToken[:maxDisplayLen] + "..."
	}
	fmt.Printf("--- Simulating request with token '%s' ---\n", displayToken)

	// 1. Perform validation by calling the dedicated validation function.
	accountID, authLevel, err := validateBearerToken(token)
	if err != nil {
		// If the validation function returns an error, the request fails.
		fmt.Printf("  => ‚ùå VALIDATION FAILED: %v.\n", err)
		fmt.Println("-------------------------------------------------")
		return
	}

	// If we get here, the token is valid.
	fmt.Printf("  Token validated for Account '%s' with '%s' level auth.\n", accountID, authLevel)

	// 2. Simulate accessing a public resource (always allowed with a valid token).
	fmt.Println("  Attempting to access PUBLIC data...")
	fmt.Printf("    => ‚úÖ SUCCESS: Public data accessible.\n")

	// 3. Simulate accessing a protected resource (requires secret level auth).
	fmt.Println("  Attempting to perform a SECRET action...")
	if authLevel == AuthLevelSecret {
		fmt.Printf("    => üîë SUCCESS: Protected action allowed.\n")
	} else {
		fmt.Printf("    => ‚ùå FAILURE: Forbidden. A secret key is required for this action.\n")
	}

	fmt.Println("-------------------------------------------------")
}

func main() {
	// --- Setup ---
	// For demonstration, we'll create one account and its keys.
	accountID := "acct_1A2B3C4D"
	publicKey, secretKey, err := setupNewAccount(accountID)
	if err != nil {
		panic(fmt.Sprintf("Failed to set up initial account: %v", err))
	}

	fmt.Println("üöÄ CLI Token Authentication Simulation")
	fmt.Println("=================================================")
	fmt.Printf("Test Account ID: %s\n", accountID)
	fmt.Printf("Public Key: %s\n", publicKey)
	fmt.Printf("Secret Key: %s\n", secretKey)
	fmt.Println("=================================================")

	// --- Test Cases ---
	// 1. Simulate a request with the PUBLIC key.
	simulateApiRequest(publicKey)

	// 2. Simulate a request with the SECRET key.
	simulateApiRequest(secretKey)

	// 3. Simulate a request with a BAD token.
	simulateApiRequest("pk_badtoken12345")
}
