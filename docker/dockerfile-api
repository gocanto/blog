# --- Build Arguments
ARG GO_VERSION=1.24
ARG ALPINE_VERSION=latest

ARG APP_VERSION="0.0.0-dev"
ARG BUILD_TAGS="posts,experience,profile,projects,social,talks,gus,gocanto"

ARG BINARY_NAME=server
ARG APP_HOST_PORT=8080
ARG APP_USER=appuser
ARG APP_GROUP=appgroup
ARG APP_HOME=/home/${APP_USER}

ARG BUILD_DIR=/app
ARG STORAGE_DIR=storage
ARG LOGS_DIR=logs
ARG MEDIA_DIR=media
ARG FIXTURES_DIR=fixture

# --- Build Stage
FROM golang:${GO_VERSION}-alpine AS builder

# --- Docker Args always go before ENV vars.
#     Forwards build-time arguments into this specific stage so they can be referenced.
ARG BUILD_DIR
ARG BINARY_NAME
ARG APP_VERSION
ARG BUILD_TAGS

# --- Go env vars.
#     Tell Go to keep its module & build caches under /app
ENV GOPATH=${BUILD_DIR}/.gopath
ENV GOMODCACHE=${BUILD_DIR}/.gopath/pkg/mod
ENV GOCACHE=${BUILD_DIR}/.gocache
RUN mkdir -p ${GOMODCACHE} ${GOCACHE}

# Install timezone data so Go’s time.* calls work correctly.
RUN apk add --no-cache tzdata

# Sets the primary working directory for this stage of the build.
WORKDIR ${BUILD_DIR}

# Copies the Go module definition files into the builder.
# This is done first to leverage Docker's layer caching. The subsequent
# 'go mod download' step will only be re-run if these files have changed.
COPY go.mod go.sum ./

RUN go mod download

# Copies the rest of the application's source code into the builder.
COPY . .

# Compiles the Go application into a single, statically-linked binary.
# -tags: Applies build constraints, allowing for conditional compilation.
# -o: Specifies the output path and name for the compiled binary.
# -ldflags: Provides flags to the linker.
#   -s: Strips the symbol table, reducing binary size.
#   -w: Strips DWARF debugging information, further reducing size.
#   -X: Injects a value into a string variable at build time. Here, it sets
#       the application's version by targeting the 'Version' variable in the 'main' package.
RUN CGO_ENABLED=0 go build -tags "${BUILD_TAGS}" -o ${BUILD_DIR}/${BINARY_NAME} -ldflags="-s -w -X main.Version=${APP_VERSION}" .

# --- Final Stage
FROM alpine:${ALPINE_VERSION}
#USER root

# Forwards build-time arguments into this final stage so they can be referenced.
ARG APP_USER
ARG APP_GROUP
#ARG APP_HOME
ARG BUILD_DIR
ARG BINARY_NAME
ARG STORAGE_DIR
ARG LOGS_DIR
ARG MEDIA_DIR
ARG FIXTURES_DIR
ARG APP_HOST_PORT

# Creates a dedicated, non-root user and group to run the application with.
#RUN addgroup -S ${APP_GROUP} && adduser -S ${APP_USER} -G ${APP_GROUP} -h ${APP_HOME}

# Make sure the home exists & switch into it.
WORKDIR /app

# Creates the necessary storage directories inside the container.
RUN mkdir -p ${STORAGE_DIR}/${LOGS_DIR} ${STORAGE_DIR}/${MEDIA_DIR}
RUN mkdir -p ${STORAGE_DIR}/${FIXTURES_DIR} ${STORAGE_DIR}/${FIXTURES_DIR}

# Copies the 'fixture' files from the local project directory into the container.
COPY ${STORAGE_DIR}/${FIXTURES_DIR} ./${STORAGE_DIR}/${FIXTURES_DIR}/

# Copies the compiled application binary from the 'builder' stage.
COPY --from=builder ${BUILD_DIR}/${BINARY_NAME} /${BUILD_DIR}/${BINARY_NAME}

# Copy timezone data from builder so Go’s time.* calls work correctly.
#RUN apk add --no-cache tzdata
COPY --from=builder /usr/share/zoneinfo /usr/share/zoneinfo

# Recursively sets the ownership of all files in the application's home directory.
#RUN chown -R ${APP_USER}:${APP_GROUP} ${APP_HOME}

#USER ${APP_USER}

EXPOSE ${APP_HOST_PORT}

#CMD ["./server"]
CMD ["/app/${BINARY_NAME}"]
